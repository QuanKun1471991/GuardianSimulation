{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nvar _s = $RefreshSig$();\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nimport { useEffect, useState } from \"react\";\nvar elements = {\n  TropicalStorm: {\n    layers: [{\n      name: \"TropicalStorm\",\n      idx: 1,\n      element: \"TropicalStorm\",\n      ref: undefined\n    }],\n    timecontrolled: false,\n    data: undefined\n  },\n  WaveHeight: {\n    layers: [{\n      name: \"WaveHeight\",\n      idx: 10,\n      element: \"HTSGW\",\n      ref: undefined,\n      extraContents: {\n        filter: \"missing 1\"\n      }\n    }, {\n      name: \"WaveHeightContour\",\n      idx: 9,\n      element: \"HTSGW\",\n      ref: undefined,\n      extraContents: {\n        filter: \"missing 1\"\n      }\n    }],\n    timecontrolled: true,\n    data: undefined,\n    mask: {\n      name: \"LandMask\",\n      ref: undefined,\n      data: undefined\n    }\n  },\n  SurfacePressure: {\n    layers: [{\n      name: \"SurfacePressure\",\n      idx: 5,\n      element: \"PRMSL\",\n      ref: undefined\n    }],\n    timecontrolled: true,\n    data: undefined\n  }\n};\nvar layerMasks = {};\n\nfunction reformDate(date) {\n  var yy = date.getUTCFullYear();\n  var mm = String(date.getUTCMonth() + 1).padStart(2, \"0\");\n  var dd = String(date.getUTCDate()).padStart(2, \"0\");\n  var HH = String(date.getUTCHours()).padStart(2, \"0\");\n  var MM = String(date.getUTCMinutes()).padStart(2, \"0\");\n  var SS = String(date.getUTCSeconds()).padStart(2, \"0\");\n  return \"\".concat(yy).concat(mm).concat(dd, \"T\").concat(HH).concat(MM).concat(SS);\n}\n\nfunction updateDataNonTimeContent(source, ref) {\n  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : reformDate(new Date());\n  var refindex = ref.query(\"index\").value();\n  var refdata = ref.query(\"data\").value();\n\n  if (refindex && refindex.index) {\n    for (var id in refindex.index) {\n      var trop = refindex.index[id];\n      if (trop.final_flag === 1 && !trop.valid_end) delete refdata[id];else if (trop.final_flag === 1 && trop.valid_end < time) delete refdata[id];\n    }\n  }\n\n  var _iterator = _createForOfIteratorHelper(source.layers),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var layer = _step.value;\n      updateModelContent(layer, time, time);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction updateDataTimeContent(source, ref) {\n  var time = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : reformDate(new Date());\n  var timelist = ref.query(\"timelist\").value();\n\n  if (timelist && timelist.length) {\n    if (timelist && timelist.length > 1) {\n      if (timelist[0].basetime < timelist[1].basetime) {\n        timelist = timelist.reverse();\n      }\n    } // Get Nearest latest BaseTime\n\n\n    var bt = \"\";\n    var vl = [];\n    var vt = \"\";\n\n    for (var i = 0; i < timelist.length; i++) {\n      bt = timelist[i].basetime;\n      vl = timelist[i].validtime;\n      if (bt <= time) break;\n    } // Get Nearest latest ValidTime\n\n\n    for (var _i = 0; _i < vl.length; _i++) {\n      vt = vl[_i];\n      if (vt <= time) break;\n    }\n\n    var _iterator2 = _createForOfIteratorHelper(source.layers),\n        _step2;\n\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var layer = _step2.value;\n        updateModelContent(layer, bt, vt);\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n  }\n}\n\nfunction updateModelContent(layer, baseTime, validTime) {\n  if (baseTime === \"\") return;\n  if (validTime === \"\") return;\n  if (layer === null) return;\n  if (layer.ref === undefined) return;\n  var visibility = layer.ref.visible();\n  layer.ref.setVisible(false);\n\n  var content = _objectSpread({\n    element: layer.element,\n    basetime: baseTime,\n    validtime: validTime\n  }, layer.extraContents || {}); // Check Layer Masks\n\n\n  for (var mask_id in layerMasks) {\n    var mask = layerMasks[mask_id];\n    mask.ref.setVisible(false);\n\n    var _iterator3 = _createForOfIteratorHelper(mask.layers),\n        _step3;\n\n    try {\n      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n        var mlayer = _step3.value;\n        mlayer.merge([mask.ref]);\n\n        if (mlayer.visible()) {\n          mask.ref.setVisible(true);\n        }\n      }\n    } catch (err) {\n      _iterator3.e(err);\n    } finally {\n      _iterator3.f();\n    }\n  }\n\n  layer.ref.set(content);\n  layer.ref.setVisible(visibility);\n}\n\nfunction init() {\n  WRAP.DH.conf_path = \"./weatherConfig/data\"; // Init Weather Layers\n\n  var tmp_wx_list = [];\n\n  var _loop = function _loop(el) {\n    if (elements[el].data === undefined) {\n      elements[el].data = WRAP.DH.addObject(\"/\".concat(el));\n      elements[el].data.inspect(function () {\n        if (elements[el].timecontrolled) updateDataTimeContent(elements[el], elements[el].data);else updateDataNonTimeContent(elements[el], elements[el].data);\n      }, true);\n    }\n\n    var _iterator4 = _createForOfIteratorHelper(elements[el].layers),\n        _step4;\n\n    try {\n      var _loop2 = function _loop2() {\n        var ly = _step4.value;\n        var layerName = ly.name;\n        var layer = new WRAP.Geo.Layer(layerName);\n        layer.setVisible(false);\n        ly.ref = layer; // Create Layer Mask\n\n        if (elements[el].mask) {\n          var mask = elements[el].mask;\n\n          if (layerMasks[mask.name] === undefined) {\n            var mask_data = WRAP.DH.addObject(\"/\".concat(mask.name));\n            var mask_layer = new WRAP.Geo.Layer(mask.name);\n\n            _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n              var result, layer_conf;\n              return _regeneratorRuntime.wrap(function _callee$(_context) {\n                while (1) {\n                  switch (_context.prev = _context.next) {\n                    case 0:\n                      _context.next = 2;\n                      return fetch(\"./resources/conf/layer/\".concat(mask.name, \".json\"));\n\n                    case 2:\n                      result = _context.sent;\n                      _context.next = 5;\n                      return result.json();\n\n                    case 5:\n                      layer_conf = _context.sent;\n                      mask_layer.configure(mask_data, layer_conf);\n                      mask_layer.set({});\n\n                    case 8:\n                    case \"end\":\n                      return _context.stop();\n                  }\n                }\n              }, _callee);\n            }))();\n\n            mask_layer.setVisible(false);\n            layerMasks[mask.name] = {\n              layers: [],\n              ref: mask_layer\n            };\n          }\n\n          layerMasks[mask.name].layers.push(layer);\n          ly.mask = layerMasks[mask.name];\n        }\n\n        tmp_wx_list.push(ly);\n\n        _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var result, layer_conf;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return fetch(\"./weatherConf/layer/\".concat(layerName, \".json\"));\n\n                case 2:\n                  result = _context2.sent;\n                  _context2.next = 5;\n                  return result.json();\n\n                case 5:\n                  layer_conf = _context2.sent;\n                  ly.ref.configure(elements[el].data, layer_conf);\n\n                case 7:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2);\n        }))();\n      };\n\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        _loop2();\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  };\n\n  for (var el in elements) {\n    _loop(el);\n  }\n\n  tmp_wx_list = tmp_wx_list.sort(function (a, b) {\n    return a.idx - b.idx;\n  });\n  var layers = tmp_wx_list.concat(Object.values(layerMasks));\n  WRAP.Geo.setLayer({\n    upper_layers: layers.map(function (item) {\n      return item.ref;\n    })\n  });\n  return tmp_wx_list;\n}\n\nfunction Index(_ref3) {\n  _s();\n\n  var guardianMap = _ref3.guardianMap,\n      onSetLayers = _ref3.onSetLayers,\n      showWaveHeight = _ref3.showWaveHeight,\n      showPressurePattern = _ref3.showPressurePattern,\n      showTropicalStorm = _ref3.showTropicalStorm,\n      date = _ref3.date;\n\n  var _useState = useState([]),\n      wxList = _useState[0],\n      setWxList = _useState[1];\n\n  useEffect(function () {\n    WRAP.Geo.setOpenLayers(guardianMap);\n    setWxList(init());\n  }, [guardianMap]);\n  useEffect(function () {\n    for (var el in elements) {\n      var newdate = reformDate(new Date());\n      if (elements[el].timecontrolled) updateDataTimeContent(elements[el], elements[el].data, newdate);\n    }\n  }, [date]);\n  useEffect(function () {\n    wxList.forEach(function (wx) {\n      if (!wx.name.indexOf(\"WaveHeight\")) {\n        wx.ref.setVisible(showWaveHeight);\n        wx.mask.ref.setVisible(showWaveHeight);\n      }\n\n      if (wx.name === \"TropicalStorm\") {\n        wx.ref.setVisible(showTropicalStorm);\n      }\n\n      if (wx.name === \"SurfacePressure\") {\n        wx.ref.setVisible(showPressurePattern);\n      }\n    });\n  }, [onSetLayers, showWaveHeight, showPressurePattern, showTropicalStorm, wxList]);\n  return null;\n} // const mapStateToProps = (state: any, props: any) => state.cargoMap.weatherForecast\n\n\n_s(Index, \"GJEJBDbY8VU+pPYK8nmFALvcaEU=\");\n\n_c = Index;\nexport default Index;\n\nvar _c;\n\n$RefreshReg$(_c, \"Index\");","map":{"version":3,"sources":["/Users/tonysan/Desktop/guardian-simulation/GuardianSimulation/src/components/Layers/WeatherForecast/index.tsx"],"names":["useEffect","useState","elements","TropicalStorm","layers","name","idx","element","ref","undefined","timecontrolled","data","WaveHeight","extraContents","filter","mask","SurfacePressure","layerMasks","reformDate","date","yy","getUTCFullYear","mm","String","getUTCMonth","padStart","dd","getUTCDate","HH","getUTCHours","MM","getUTCMinutes","SS","getUTCSeconds","updateDataNonTimeContent","source","time","Date","refindex","query","value","refdata","index","id","trop","final_flag","valid_end","layer","updateModelContent","updateDataTimeContent","timelist","length","basetime","reverse","bt","vl","vt","i","validtime","baseTime","validTime","visibility","visible","setVisible","content","mask_id","mlayer","merge","set","init","WRAP","DH","conf_path","tmp_wx_list","el","addObject","inspect","ly","layerName","Geo","Layer","mask_data","mask_layer","fetch","result","json","layer_conf","configure","push","sort","a","b","concat","Object","values","setLayer","upper_layers","map","item","Index","guardianMap","onSetLayers","showWaveHeight","showPressurePattern","showTropicalStorm","wxList","setWxList","setOpenLayers","newdate","forEach","wx","indexOf"],"mappings":"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","sourcesContent":["import { useEffect, useState } from \"react\"\n\nconst elements: Record<string, unknown> = {\n  TropicalStorm: {\n    layers: [{ name: \"TropicalStorm\", idx: 1, element: \"TropicalStorm\", ref: undefined }],\n    timecontrolled: false,\n    data: undefined,\n  },\n  WaveHeight: {\n    layers: [\n      {\n        name: \"WaveHeight\",\n        idx: 10,\n        element: \"HTSGW\",\n        ref: undefined,\n        extraContents: { filter: \"missing 1\" },\n      },\n      {\n        name: \"WaveHeightContour\",\n        idx: 9,\n        element: \"HTSGW\",\n        ref: undefined,\n        extraContents: { filter: \"missing 1\" },\n      },\n    ],\n    timecontrolled: true,\n    data: undefined,\n    mask: { name: \"LandMask\", ref: undefined, data: undefined },\n  },\n  SurfacePressure: {\n    layers: [{ name: \"SurfacePressure\", idx: 5, element: \"PRMSL\", ref: undefined }],\n    timecontrolled: true,\n    data: undefined,\n  },\n}\nconst layerMasks = {}\nfunction reformDate(date: any) {\n  const yy = date.getUTCFullYear()\n  const mm = String(date.getUTCMonth() + 1).padStart(2, \"0\")\n  const dd = String(date.getUTCDate()).padStart(2, \"0\")\n  const HH = String(date.getUTCHours()).padStart(2, \"0\")\n  const MM = String(date.getUTCMinutes()).padStart(2, \"0\")\n  const SS = String(date.getUTCSeconds()).padStart(2, \"0\")\n  return `${yy}${mm}${dd}T${HH}${MM}${SS}`\n}\nfunction updateDataNonTimeContent(source: any, ref: any, time = reformDate(new Date())) {\n  const refindex = ref.query(\"index\").value()\n  const refdata = ref.query(\"data\").value()\n  if (refindex && refindex.index) {\n    for (const id in refindex.index) {\n      const trop = refindex.index[id]\n      if (trop.final_flag === 1 && !trop.valid_end) delete refdata[id]\n      else if (trop.final_flag === 1 && trop.valid_end < time) delete refdata[id]\n    }\n  }\n  for (const layer of source.layers) {\n    updateModelContent(layer, time, time)\n  }\n}\n\nfunction updateDataTimeContent(source: any, ref: any, time = reformDate(new Date())) {\n  let timelist = ref.query(\"timelist\").value()\n  if (timelist && timelist.length) {\n    if (timelist && timelist.length > 1) {\n      if (timelist[0].basetime < timelist[1].basetime) {\n        timelist = timelist.reverse()\n      }\n    }\n\n    // Get Nearest latest BaseTime\n    let bt = \"\"\n    let vl = []\n    let vt = \"\"\n    for (let i = 0; i < timelist.length; i++) {\n      bt = timelist[i].basetime\n      vl = timelist[i].validtime\n      if (bt <= time) break\n    }\n\n    // Get Nearest latest ValidTime\n    for (let i = 0; i < vl.length; i++) {\n      vt = vl[i]\n      if (vt <= time) break\n    }\n\n    for (const layer of source.layers) {\n      updateModelContent(layer, bt, vt)\n    }\n  }\n}\n\nfunction updateModelContent(layer: any, baseTime: any, validTime: any) {\n  if (baseTime === \"\") return\n  if (validTime === \"\") return\n  if (layer === null) return\n  if (layer.ref === undefined) return\n\n  const visibility = layer.ref.visible()\n  layer.ref.setVisible(false)\n\n  const content = {\n    element: layer.element,\n    basetime: baseTime,\n    validtime: validTime,\n    ...(layer.extraContents || {}),\n  }\n\n  // Check Layer Masks\n  for (const mask_id in layerMasks) {\n    const mask = layerMasks[mask_id]\n    mask.ref.setVisible(false)\n    for (const mlayer of mask.layers) {\n      mlayer.merge([mask.ref])\n      if (mlayer.visible()) {\n        mask.ref.setVisible(true)\n      }\n    }\n  }\n  layer.ref.set(content)\n  layer.ref.setVisible(visibility)\n}\nfunction init() {\n  WRAP.DH.conf_path = \"./weatherConfig/data\"\n  // Init Weather Layers\n  let tmp_wx_list = []\n  for (const el in elements) {\n    if (elements[el].data === undefined) {\n      elements[el].data = WRAP.DH.addObject(`/${el}`)\n      elements[el].data.inspect(function () {\n        if (elements[el].timecontrolled) updateDataTimeContent(elements[el], elements[el].data)\n        else updateDataNonTimeContent(elements[el], elements[el].data)\n      }, true)\n    }\n    for (const ly of elements[el].layers) {\n      const layerName = ly.name\n      const layer = new WRAP.Geo.Layer(layerName)\n      layer.setVisible(false)\n      ly.ref = layer\n\n      // Create Layer Mask\n      if (elements[el].mask) {\n        const { mask } = elements[el]\n        if (layerMasks[mask.name] === undefined) {\n          const mask_data = WRAP.DH.addObject(`/${mask.name}`)\n          const mask_layer = new WRAP.Geo.Layer(mask.name)\n          ;(async () => {\n            const result = await fetch(`./resources/conf/layer/${mask.name}.json`)\n            const layer_conf = await result.json()\n            mask_layer.configure(mask_data, layer_conf)\n            mask_layer.set({})\n          })()\n          mask_layer.setVisible(false)\n          layerMasks[mask.name] = { layers: [], ref: mask_layer }\n        }\n        layerMasks[mask.name].layers.push(layer)\n        ly.mask = layerMasks[mask.name]\n      }\n\n      tmp_wx_list.push(ly)\n      ;(async () => {\n        const result = await fetch(`./weatherConf/layer/${layerName}.json`)\n        const layer_conf = await result.json()\n        ly.ref.configure(elements[el].data, layer_conf)\n      })()\n    }\n  }\n  tmp_wx_list = tmp_wx_list.sort(function (a, b) {\n    return a.idx - b.idx\n  })\n  const layers = tmp_wx_list.concat(Object.values(layerMasks))\n  WRAP.Geo.setLayer({\n    upper_layers: layers.map(function (item) {\n      return item.ref\n    }),\n  })\n  return tmp_wx_list\n}\nfunction Index({\n  guardianMap,\n  onSetLayers,\n  showWaveHeight,\n  showPressurePattern,\n  showTropicalStorm,\n  date,\n}: any) {\n  const [wxList, setWxList] = useState<any[]>([])\n  useEffect(() => {\n    WRAP.Geo.setOpenLayers(guardianMap)\n    setWxList(init())\n  }, [guardianMap])\n\n  useEffect(() => {\n    for (const el in elements) {\n      const newdate = reformDate(new Date())\n      if (elements[el].timecontrolled)\n        updateDataTimeContent(elements[el], elements[el].data, newdate)\n    }\n  }, [date])\n\n  useEffect(() => {\n    wxList.forEach((wx) => {\n      if (!wx.name.indexOf(\"WaveHeight\")) {\n        wx.ref.setVisible(showWaveHeight)\n        wx.mask.ref.setVisible(showWaveHeight)\n      }\n      if (wx.name === \"TropicalStorm\") {\n        wx.ref.setVisible(showTropicalStorm)\n      }\n      if (wx.name === \"SurfacePressure\") {\n        wx.ref.setVisible(showPressurePattern)\n      }\n    })\n  }, [onSetLayers, showWaveHeight, showPressurePattern, showTropicalStorm, wxList])\n  return null\n}\n// const mapStateToProps = (state: any, props: any) => state.cargoMap.weatherForecast\n\nexport default Index\n"]},"metadata":{},"sourceType":"module"}