{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport { SagaInjectionModes } from \"core/constants/common\";\nimport checkStore, { invariant } from \"core/utils/redux\";\nimport { conformsTo, isEmpty, isFunction, isString } from \"lodash\";\n\nvar checkKey = function checkKey(key) {\n  return invariant(isString(key) && !isEmpty(key), \"(app/utils...) injectSaga: Expected `key` to be a non empty string\");\n};\n\nvar checkDescriptor = function checkDescriptor(descriptor) {\n  var shape = {\n    saga: isFunction,\n    mode: function mode(_mode) {\n      return isString(_mode);\n    }\n  };\n  invariant(conformsTo(descriptor, shape), \"(app/utils...) injectSaga: Expected a valid saga descriptor\");\n};\n\nexport function injectSagaFactory(store, isValid) {\n  return function injectSaga(key, descriptor, args) {\n    if (!isValid) {\n      checkStore(store);\n    }\n\n    var newDescriptor = _objectSpread(_objectSpread({}, descriptor), {}, {\n      mode: descriptor.mode || SagaInjectionModes.DAEMON\n    });\n\n    var saga = newDescriptor.saga,\n        mode = newDescriptor.mode;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    var hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (true) {\n      var oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (!hasSaga || hasSaga && mode !== SagaInjectionModes.DAEMON && mode !== SagaInjectionModes.ONCE_TILL_UNMOUNT) {\n      var _store$runSaga;\n\n      // eslint-disable-next-line no-param-reassign\n      store.injectedSagas = _objectSpread(_objectSpread({}, store.injectedSagas), {}, _defineProperty({}, key, _objectSpread(_objectSpread({}, newDescriptor), {}, {\n        task: (_store$runSaga = store.runSaga) === null || _store$runSaga === void 0 ? void 0 : _store$runSaga.call(store, saga, args)\n      })));\n    }\n\n    return store;\n  };\n}\nexport function ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) {\n      checkStore(store);\n    }\n\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      var descriptor = store.injectedSagas[key];\n\n      if (descriptor.mode && descriptor.mode !== SagaInjectionModes.DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (false) {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = \"done\"; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n\n    return store;\n  };\n}\nexport default function getInjectors(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}","map":{"version":3,"sources":["/Users/tonysan/Desktop/guardian-simulation/GuardianSimulation/src/services/_base/injectSagas.ts"],"names":["SagaInjectionModes","checkStore","invariant","conformsTo","isEmpty","isFunction","isString","checkKey","key","checkDescriptor","descriptor","shape","saga","mode","injectSagaFactory","store","isValid","injectSaga","args","newDescriptor","DAEMON","hasSaga","Reflect","has","injectedSagas","oldDescriptor","task","cancel","ONCE_TILL_UNMOUNT","runSaga","ejectSagaFactory","ejectSaga","getInjectors"],"mappings":"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","sourcesContent":["import { SagaInjectionModes } from \"core/constants/common\"\nimport checkStore, { invariant } from \"core/utils/redux\"\nimport { conformsTo, isEmpty, isFunction, isString } from \"lodash\"\nimport { Saga } from \"redux-saga\"\nimport { GetInjectors, IAppState, InjectedStore } from \"types/redux\"\n\nconst checkKey = (key: keyof IAppState) =>\n  invariant(\n    isString(key) && !isEmpty(key),\n    \"(app/utils...) injectSaga: Expected `key` to be a non empty string\"\n  )\n\nconst checkDescriptor = (descriptor: { saga: Saga; mode: SagaInjectionModes }) => {\n  const shape = {\n    saga: isFunction,\n    mode: (mode: string) => isString(mode),\n  }\n  invariant(\n    conformsTo(descriptor, shape),\n    \"(app/utils...) injectSaga: Expected a valid saga descriptor\"\n  )\n}\n\nexport function injectSagaFactory(store: InjectedStore, isValid: boolean) {\n  return function injectSaga<T>(\n    key: keyof IAppState,\n    descriptor: { mode?: SagaInjectionModes; saga: Saga },\n    args?: T\n  ) {\n    if (!isValid) {\n      checkStore(store)\n    }\n\n    const newDescriptor = {\n      ...descriptor,\n      mode: descriptor.mode || SagaInjectionModes.DAEMON,\n    }\n    const { saga, mode } = newDescriptor\n\n    checkKey(key)\n    checkDescriptor(newDescriptor)\n\n    let hasSaga = Reflect.has(store.injectedSagas, key)\n\n    if (process.env.NODE_ENV !== \"production\") {\n      const oldDescriptor = store.injectedSagas[key]\n      // enable hot reloading of daemon and once-till-unmount sagas\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel()\n        hasSaga = false\n      }\n    }\n\n    if (\n      !hasSaga ||\n      (hasSaga &&\n        mode !== SagaInjectionModes.DAEMON &&\n        mode !== SagaInjectionModes.ONCE_TILL_UNMOUNT)\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      store.injectedSagas = {\n        ...store.injectedSagas,\n        [key]: {\n          ...newDescriptor,\n          task: store.runSaga?.(saga, args),\n        },\n      }\n    }\n\n    return store\n  }\n}\n\nexport function ejectSagaFactory(store: InjectedStore, isValid: boolean) {\n  return function ejectSaga(key: keyof IAppState) {\n    if (!isValid) {\n      checkStore(store)\n    }\n\n    checkKey(key)\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key]\n\n      if (descriptor.mode && descriptor.mode !== SagaInjectionModes.DAEMON) {\n        descriptor.task.cancel()\n\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\n        if (process.env.NODE_ENV === \"production\") {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = \"done\" // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n\n    return store\n  }\n}\n\nexport default function getInjectors(store: InjectedStore): GetInjectors {\n  checkStore(store)\n\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true),\n  }\n}\n"]},"metadata":{},"sourceType":"module"}