{"ast":null,"code":"import _conformsTo from \"lodash/conformsTo\";\nimport _isFunction from \"lodash/isFunction\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _isString from \"lodash/isString\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { SagaInjectionModes } from \"core/constants/common\";\nimport checkStore, { invariant } from \"core/utils/redux\";\n\nconst checkKey = key => invariant(_isString(key) && !_isEmpty(key), \"(app/utils...) injectSaga: Expected `key` to be a non empty string\");\n\nconst checkDescriptor = descriptor => {\n  const shape = {\n    saga: _isFunction,\n    mode: mode => _isString(mode)\n  };\n  invariant(_conformsTo(descriptor, shape), \"(app/utils...) injectSaga: Expected a valid saga descriptor\");\n};\n\nexport function injectSagaFactory(store, isValid) {\n  return function injectSaga(key, descriptor, args) {\n    if (!isValid) {\n      checkStore(store);\n    }\n\n    const newDescriptor = _objectSpread(_objectSpread({}, descriptor), {}, {\n      mode: descriptor.mode || SagaInjectionModes.DAEMON\n    });\n\n    const {\n      saga,\n      mode\n    } = newDescriptor;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    let hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (true) {\n      const oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (!hasSaga || hasSaga && mode !== SagaInjectionModes.DAEMON && mode !== SagaInjectionModes.ONCE_TILL_UNMOUNT) {\n      var _store$runSaga;\n\n      // eslint-disable-next-line no-param-reassign\n      store.injectedSagas = _objectSpread(_objectSpread({}, store.injectedSagas), {}, {\n        [key]: _objectSpread(_objectSpread({}, newDescriptor), {}, {\n          task: (_store$runSaga = store.runSaga) === null || _store$runSaga === void 0 ? void 0 : _store$runSaga.call(store, saga, args)\n        })\n      });\n    }\n\n    return store;\n  };\n}\nexport function ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) {\n      checkStore(store);\n    }\n\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key];\n\n      if (descriptor.mode && descriptor.mode !== SagaInjectionModes.DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (false) {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = \"done\"; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n\n    return store;\n  };\n}\nexport default function getInjectors(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}","map":{"version":3,"sources":["/Users/tonysan/Desktop/guardian-simulation/GuardianSimulation/src/services/_base/injectSagas.ts"],"names":["SagaInjectionModes","checkStore","invariant","checkKey","key","checkDescriptor","descriptor","shape","saga","mode","injectSagaFactory","store","isValid","injectSaga","args","newDescriptor","DAEMON","hasSaga","Reflect","has","injectedSagas","oldDescriptor","task","cancel","ONCE_TILL_UNMOUNT","runSaga","ejectSagaFactory","ejectSaga","getInjectors"],"mappings":"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","sourcesContent":["import { SagaInjectionModes } from \"core/constants/common\"\nimport checkStore, { invariant } from \"core/utils/redux\"\nimport { conformsTo, isEmpty, isFunction, isString } from \"lodash\"\nimport { Saga } from \"redux-saga\"\nimport { GetInjectors, IAppState, InjectedStore } from \"types/redux\"\n\nconst checkKey = (key: keyof IAppState) =>\n  invariant(\n    isString(key) && !isEmpty(key),\n    \"(app/utils...) injectSaga: Expected `key` to be a non empty string\"\n  )\n\nconst checkDescriptor = (descriptor: { saga: Saga; mode: SagaInjectionModes }) => {\n  const shape = {\n    saga: isFunction,\n    mode: (mode: string) => isString(mode),\n  }\n  invariant(\n    conformsTo(descriptor, shape),\n    \"(app/utils...) injectSaga: Expected a valid saga descriptor\"\n  )\n}\n\nexport function injectSagaFactory(store: InjectedStore, isValid: boolean) {\n  return function injectSaga<T>(\n    key: keyof IAppState,\n    descriptor: { mode?: SagaInjectionModes; saga: Saga },\n    args?: T\n  ) {\n    if (!isValid) {\n      checkStore(store)\n    }\n\n    const newDescriptor = {\n      ...descriptor,\n      mode: descriptor.mode || SagaInjectionModes.DAEMON,\n    }\n    const { saga, mode } = newDescriptor\n\n    checkKey(key)\n    checkDescriptor(newDescriptor)\n\n    let hasSaga = Reflect.has(store.injectedSagas, key)\n\n    if (process.env.NODE_ENV !== \"production\") {\n      const oldDescriptor = store.injectedSagas[key]\n      // enable hot reloading of daemon and once-till-unmount sagas\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel()\n        hasSaga = false\n      }\n    }\n\n    if (\n      !hasSaga ||\n      (hasSaga &&\n        mode !== SagaInjectionModes.DAEMON &&\n        mode !== SagaInjectionModes.ONCE_TILL_UNMOUNT)\n    ) {\n      // eslint-disable-next-line no-param-reassign\n      store.injectedSagas = {\n        ...store.injectedSagas,\n        [key]: {\n          ...newDescriptor,\n          task: store.runSaga?.(saga, args),\n        },\n      }\n    }\n\n    return store\n  }\n}\n\nexport function ejectSagaFactory(store: InjectedStore, isValid: boolean) {\n  return function ejectSaga(key: keyof IAppState) {\n    if (!isValid) {\n      checkStore(store)\n    }\n\n    checkKey(key)\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key]\n\n      if (descriptor.mode && descriptor.mode !== SagaInjectionModes.DAEMON) {\n        descriptor.task.cancel()\n\n        // Clean up in production; in development we need `descriptor.saga` for hot reloading\n        if (process.env.NODE_ENV === \"production\") {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = \"done\" // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n\n    return store\n  }\n}\n\nexport default function getInjectors(store: InjectedStore): GetInjectors {\n  checkStore(store)\n\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true),\n  }\n}\n"]},"metadata":{},"sourceType":"module"}