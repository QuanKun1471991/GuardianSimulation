{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useEffect, useState } from \"react\";\nconst elements = {\n  TropicalStorm: {\n    layers: [{\n      name: \"TropicalStorm\",\n      idx: 1,\n      element: \"TropicalStorm\",\n      ref: undefined\n    }],\n    timecontrolled: false,\n    data: undefined\n  },\n  WaveHeight: {\n    layers: [{\n      name: \"WaveHeight\",\n      idx: 10,\n      element: \"HTSGW\",\n      ref: undefined,\n      extraContents: {\n        filter: \"missing 1\"\n      }\n    }, {\n      name: \"WaveHeightContour\",\n      idx: 9,\n      element: \"HTSGW\",\n      ref: undefined,\n      extraContents: {\n        filter: \"missing 1\"\n      }\n    }],\n    timecontrolled: true,\n    data: undefined,\n    mask: {\n      name: \"LandMask\",\n      ref: undefined,\n      data: undefined\n    }\n  },\n  SurfacePressure: {\n    layers: [{\n      name: \"SurfacePressure\",\n      idx: 5,\n      element: \"PRMSL\",\n      ref: undefined\n    }],\n    timecontrolled: true,\n    data: undefined\n  }\n};\nconst layerMasks = {};\n\nfunction reformDate(date) {\n  const yy = date.getUTCFullYear();\n  const mm = String(date.getUTCMonth() + 1).padStart(2, \"0\");\n  const dd = String(date.getUTCDate()).padStart(2, \"0\");\n  const HH = String(date.getUTCHours()).padStart(2, \"0\");\n  const MM = String(date.getUTCMinutes()).padStart(2, \"0\");\n  const SS = String(date.getUTCSeconds()).padStart(2, \"0\");\n  return `${yy}${mm}${dd}T${HH}${MM}${SS}`;\n}\n\nfunction updateDataNonTimeContent(source, ref, time = reformDate(new Date())) {\n  const refindex = ref.query(\"index\").value();\n  const refdata = ref.query(\"data\").value();\n\n  if (refindex && refindex.index) {\n    for (const id in refindex.index) {\n      const trop = refindex.index[id];\n      if (trop.final_flag === 1 && !trop.valid_end) delete refdata[id];else if (trop.final_flag === 1 && trop.valid_end < time) delete refdata[id];\n    }\n  }\n\n  for (const layer of source.layers) {\n    updateModelContent(layer, time, time);\n  }\n}\n\nfunction updateDataTimeContent(source, ref, time = reformDate(new Date())) {\n  let timelist = ref.query(\"timelist\").value();\n\n  if (timelist && timelist.length) {\n    if (timelist && timelist.length > 1) {\n      if (timelist[0].basetime < timelist[1].basetime) {\n        timelist = timelist.reverse();\n      }\n    } // Get Nearest latest BaseTime\n\n\n    let bt = \"\";\n    let vl = [];\n    let vt = \"\";\n\n    for (let i = 0; i < timelist.length; i++) {\n      bt = timelist[i].basetime;\n      vl = timelist[i].validtime;\n      if (bt <= time) break;\n    } // Get Nearest latest ValidTime\n\n\n    for (let i = 0; i < vl.length; i++) {\n      vt = vl[i];\n      if (vt <= time) break;\n    }\n\n    for (const layer of source.layers) {\n      updateModelContent(layer, bt, vt);\n    }\n  }\n}\n\nfunction updateModelContent(layer, baseTime, validTime) {\n  if (baseTime === \"\") return;\n  if (validTime === \"\") return;\n  if (layer === null) return;\n  if (layer.ref === undefined) return;\n  const visibility = layer.ref.visible();\n  layer.ref.setVisible(false);\n\n  const content = _objectSpread({\n    element: layer.element,\n    basetime: baseTime,\n    validtime: validTime\n  }, layer.extraContents || {}); // Check Layer Masks\n\n\n  for (const mask_id in layerMasks) {\n    const mask = layerMasks[mask_id];\n    mask.ref.setVisible(false);\n\n    for (const mlayer of mask.layers) {\n      mlayer.merge([mask.ref]);\n\n      if (mlayer.visible()) {\n        mask.ref.setVisible(true);\n      }\n    }\n  }\n\n  layer.ref.set(content);\n  layer.ref.setVisible(visibility);\n}\n\nfunction init() {\n  WRAP.DH.conf_path = \"./weatherConfig/data\"; // Init Weather Layers\n\n  let tmp_wx_list = [];\n\n  for (const el in elements) {\n    if (elements[el].data === undefined) {\n      elements[el].data = WRAP.DH.addObject(`/${el}`);\n      elements[el].data.inspect(function () {\n        if (elements[el].timecontrolled) updateDataTimeContent(elements[el], elements[el].data);else updateDataNonTimeContent(elements[el], elements[el].data);\n      }, true);\n    }\n\n    for (const ly of elements[el].layers) {\n      const layerName = ly.name;\n      const layer = new WRAP.Geo.Layer(layerName);\n      layer.setVisible(false);\n      ly.ref = layer; // Create Layer Mask\n\n      if (elements[el].mask) {\n        const {\n          mask\n        } = elements[el];\n\n        if (layerMasks[mask.name] === undefined) {\n          const mask_data = WRAP.DH.addObject(`/${mask.name}`);\n          const mask_layer = new WRAP.Geo.Layer(mask.name);\n\n          (async () => {\n            const result = await fetch(`./resources/conf/layer/${mask.name}.json`);\n            const layer_conf = await result.json();\n            mask_layer.configure(mask_data, layer_conf);\n            mask_layer.set({});\n          })();\n\n          mask_layer.setVisible(false);\n          layerMasks[mask.name] = {\n            layers: [],\n            ref: mask_layer\n          };\n        }\n\n        layerMasks[mask.name].layers.push(layer);\n        ly.mask = layerMasks[mask.name];\n      }\n\n      tmp_wx_list.push(ly);\n\n      (async () => {\n        const result = await fetch(`./weatherConf/layer/${layerName}.json`);\n        const layer_conf = await result.json();\n        ly.ref.configure(elements[el].data, layer_conf);\n      })();\n    }\n  }\n\n  tmp_wx_list = tmp_wx_list.sort(function (a, b) {\n    return a.idx - b.idx;\n  });\n  const layers = tmp_wx_list.concat(Object.values(layerMasks));\n  WRAP.Geo.setLayer({\n    upper_layers: layers.map(function (item) {\n      return item.ref;\n    })\n  });\n  return tmp_wx_list;\n}\n\nfunction Index({\n  guardianMap,\n  onSetLayers,\n  showWaveHeight,\n  showPressurePattern,\n  showTropicalStorm,\n  date\n}) {\n  const {\n    0: wxList,\n    1: setWxList\n  } = useState([]);\n  useEffect(() => {\n    WRAP.Geo.setOpenLayers(guardianMap);\n    setWxList(init());\n  }, [guardianMap]);\n  useEffect(() => {\n    for (const el in elements) {\n      const newdate = reformDate(new Date());\n      if (elements[el].timecontrolled) updateDataTimeContent(elements[el], elements[el].data, newdate);\n    }\n  }, [date]);\n  useEffect(() => {\n    wxList.forEach(wx => {\n      if (!wx.name.indexOf(\"WaveHeight\")) {\n        wx.ref.setVisible(showWaveHeight);\n        wx.mask.ref.setVisible(showWaveHeight);\n      }\n\n      if (wx.name === \"TropicalStorm\") {\n        wx.ref.setVisible(showTropicalStorm);\n      }\n\n      if (wx.name === \"SurfacePressure\") {\n        wx.ref.setVisible(showPressurePattern);\n      }\n    });\n  }, [onSetLayers, showWaveHeight, showPressurePattern, showTropicalStorm, wxList]);\n  return null;\n} // const mapStateToProps = (state: any, props: any) => state.cargoMap.weatherForecast\n\n\nexport default Index;","map":{"version":3,"sources":["/Users/tonysan/Desktop/guardian-simulation/GuardianSimulation/src/components/Layers/WeatherForecast/index.tsx"],"names":["useEffect","useState","elements","TropicalStorm","layers","name","idx","element","ref","undefined","timecontrolled","data","WaveHeight","extraContents","filter","mask","SurfacePressure","layerMasks","reformDate","date","yy","getUTCFullYear","mm","String","getUTCMonth","padStart","dd","getUTCDate","HH","getUTCHours","MM","getUTCMinutes","SS","getUTCSeconds","updateDataNonTimeContent","source","time","Date","refindex","query","value","refdata","index","id","trop","final_flag","valid_end","layer","updateModelContent","updateDataTimeContent","timelist","length","basetime","reverse","bt","vl","vt","i","validtime","baseTime","validTime","visibility","visible","setVisible","content","mask_id","mlayer","merge","set","init","WRAP","DH","conf_path","tmp_wx_list","el","addObject","inspect","ly","layerName","Geo","Layer","mask_data","mask_layer","result","fetch","layer_conf","json","configure","push","sort","a","b","concat","Object","values","setLayer","upper_layers","map","item","Index","guardianMap","onSetLayers","showWaveHeight","showPressurePattern","showTropicalStorm","wxList","setWxList","setOpenLayers","newdate","forEach","wx","indexOf"],"mappings":";;;;;;AAAA,SAASA,SAAT,EAAoBC,QAApB,QAAoC,OAApC;AAEA,MAAMC,QAAiC,GAAG;AACxCC,EAAAA,aAAa,EAAE;AACbC,IAAAA,MAAM,EAAE,CAAC;AAAEC,MAAAA,IAAI,EAAE,eAAR;AAAyBC,MAAAA,GAAG,EAAE,CAA9B;AAAiCC,MAAAA,OAAO,EAAE,eAA1C;AAA2DC,MAAAA,GAAG,EAAEC;AAAhE,KAAD,CADK;AAEbC,IAAAA,cAAc,EAAE,KAFH;AAGbC,IAAAA,IAAI,EAAEF;AAHO,GADyB;AAMxCG,EAAAA,UAAU,EAAE;AACVR,IAAAA,MAAM,EAAE,CACN;AACEC,MAAAA,IAAI,EAAE,YADR;AAEEC,MAAAA,GAAG,EAAE,EAFP;AAGEC,MAAAA,OAAO,EAAE,OAHX;AAIEC,MAAAA,GAAG,EAAEC,SAJP;AAKEI,MAAAA,aAAa,EAAE;AAAEC,QAAAA,MAAM,EAAE;AAAV;AALjB,KADM,EAQN;AACET,MAAAA,IAAI,EAAE,mBADR;AAEEC,MAAAA,GAAG,EAAE,CAFP;AAGEC,MAAAA,OAAO,EAAE,OAHX;AAIEC,MAAAA,GAAG,EAAEC,SAJP;AAKEI,MAAAA,aAAa,EAAE;AAAEC,QAAAA,MAAM,EAAE;AAAV;AALjB,KARM,CADE;AAiBVJ,IAAAA,cAAc,EAAE,IAjBN;AAkBVC,IAAAA,IAAI,EAAEF,SAlBI;AAmBVM,IAAAA,IAAI,EAAE;AAAEV,MAAAA,IAAI,EAAE,UAAR;AAAoBG,MAAAA,GAAG,EAAEC,SAAzB;AAAoCE,MAAAA,IAAI,EAAEF;AAA1C;AAnBI,GAN4B;AA2BxCO,EAAAA,eAAe,EAAE;AACfZ,IAAAA,MAAM,EAAE,CAAC;AAAEC,MAAAA,IAAI,EAAE,iBAAR;AAA2BC,MAAAA,GAAG,EAAE,CAAhC;AAAmCC,MAAAA,OAAO,EAAE,OAA5C;AAAqDC,MAAAA,GAAG,EAAEC;AAA1D,KAAD,CADO;AAEfC,IAAAA,cAAc,EAAE,IAFD;AAGfC,IAAAA,IAAI,EAAEF;AAHS;AA3BuB,CAA1C;AAiCA,MAAMQ,UAAU,GAAG,EAAnB;;AACA,SAASC,UAAT,CAAoBC,IAApB,EAA+B;AAC7B,QAAMC,EAAE,GAAGD,IAAI,CAACE,cAAL,EAAX;AACA,QAAMC,EAAE,GAAGC,MAAM,CAACJ,IAAI,CAACK,WAAL,KAAqB,CAAtB,CAAN,CAA+BC,QAA/B,CAAwC,CAAxC,EAA2C,GAA3C,CAAX;AACA,QAAMC,EAAE,GAAGH,MAAM,CAACJ,IAAI,CAACQ,UAAL,EAAD,CAAN,CAA0BF,QAA1B,CAAmC,CAAnC,EAAsC,GAAtC,CAAX;AACA,QAAMG,EAAE,GAAGL,MAAM,CAACJ,IAAI,CAACU,WAAL,EAAD,CAAN,CAA2BJ,QAA3B,CAAoC,CAApC,EAAuC,GAAvC,CAAX;AACA,QAAMK,EAAE,GAAGP,MAAM,CAACJ,IAAI,CAACY,aAAL,EAAD,CAAN,CAA6BN,QAA7B,CAAsC,CAAtC,EAAyC,GAAzC,CAAX;AACA,QAAMO,EAAE,GAAGT,MAAM,CAACJ,IAAI,CAACc,aAAL,EAAD,CAAN,CAA6BR,QAA7B,CAAsC,CAAtC,EAAyC,GAAzC,CAAX;AACA,SAAQ,GAAEL,EAAG,GAAEE,EAAG,GAAEI,EAAG,IAAGE,EAAG,GAAEE,EAAG,GAAEE,EAAG,EAAvC;AACD;;AACD,SAASE,wBAAT,CAAkCC,MAAlC,EAA+C3B,GAA/C,EAAyD4B,IAAI,GAAGlB,UAAU,CAAC,IAAImB,IAAJ,EAAD,CAA1E,EAAwF;AACtF,QAAMC,QAAQ,GAAG9B,GAAG,CAAC+B,KAAJ,CAAU,OAAV,EAAmBC,KAAnB,EAAjB;AACA,QAAMC,OAAO,GAAGjC,GAAG,CAAC+B,KAAJ,CAAU,MAAV,EAAkBC,KAAlB,EAAhB;;AACA,MAAIF,QAAQ,IAAIA,QAAQ,CAACI,KAAzB,EAAgC;AAC9B,SAAK,MAAMC,EAAX,IAAiBL,QAAQ,CAACI,KAA1B,EAAiC;AAC/B,YAAME,IAAI,GAAGN,QAAQ,CAACI,KAAT,CAAeC,EAAf,CAAb;AACA,UAAIC,IAAI,CAACC,UAAL,KAAoB,CAApB,IAAyB,CAACD,IAAI,CAACE,SAAnC,EAA8C,OAAOL,OAAO,CAACE,EAAD,CAAd,CAA9C,KACK,IAAIC,IAAI,CAACC,UAAL,KAAoB,CAApB,IAAyBD,IAAI,CAACE,SAAL,GAAiBV,IAA9C,EAAoD,OAAOK,OAAO,CAACE,EAAD,CAAd;AAC1D;AACF;;AACD,OAAK,MAAMI,KAAX,IAAoBZ,MAAM,CAAC/B,MAA3B,EAAmC;AACjC4C,IAAAA,kBAAkB,CAACD,KAAD,EAAQX,IAAR,EAAcA,IAAd,CAAlB;AACD;AACF;;AAED,SAASa,qBAAT,CAA+Bd,MAA/B,EAA4C3B,GAA5C,EAAsD4B,IAAI,GAAGlB,UAAU,CAAC,IAAImB,IAAJ,EAAD,CAAvE,EAAqF;AACnF,MAAIa,QAAQ,GAAG1C,GAAG,CAAC+B,KAAJ,CAAU,UAAV,EAAsBC,KAAtB,EAAf;;AACA,MAAIU,QAAQ,IAAIA,QAAQ,CAACC,MAAzB,EAAiC;AAC/B,QAAID,QAAQ,IAAIA,QAAQ,CAACC,MAAT,GAAkB,CAAlC,EAAqC;AACnC,UAAID,QAAQ,CAAC,CAAD,CAAR,CAAYE,QAAZ,GAAuBF,QAAQ,CAAC,CAAD,CAAR,CAAYE,QAAvC,EAAiD;AAC/CF,QAAAA,QAAQ,GAAGA,QAAQ,CAACG,OAAT,EAAX;AACD;AACF,KAL8B,CAO/B;;;AACA,QAAIC,EAAE,GAAG,EAAT;AACA,QAAIC,EAAE,GAAG,EAAT;AACA,QAAIC,EAAE,GAAG,EAAT;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGP,QAAQ,CAACC,MAA7B,EAAqCM,CAAC,EAAtC,EAA0C;AACxCH,MAAAA,EAAE,GAAGJ,QAAQ,CAACO,CAAD,CAAR,CAAYL,QAAjB;AACAG,MAAAA,EAAE,GAAGL,QAAQ,CAACO,CAAD,CAAR,CAAYC,SAAjB;AACA,UAAIJ,EAAE,IAAIlB,IAAV,EAAgB;AACjB,KAf8B,CAiB/B;;;AACA,SAAK,IAAIqB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,EAAE,CAACJ,MAAvB,EAA+BM,CAAC,EAAhC,EAAoC;AAClCD,MAAAA,EAAE,GAAGD,EAAE,CAACE,CAAD,CAAP;AACA,UAAID,EAAE,IAAIpB,IAAV,EAAgB;AACjB;;AAED,SAAK,MAAMW,KAAX,IAAoBZ,MAAM,CAAC/B,MAA3B,EAAmC;AACjC4C,MAAAA,kBAAkB,CAACD,KAAD,EAAQO,EAAR,EAAYE,EAAZ,CAAlB;AACD;AACF;AACF;;AAED,SAASR,kBAAT,CAA4BD,KAA5B,EAAwCY,QAAxC,EAAuDC,SAAvD,EAAuE;AACrE,MAAID,QAAQ,KAAK,EAAjB,EAAqB;AACrB,MAAIC,SAAS,KAAK,EAAlB,EAAsB;AACtB,MAAIb,KAAK,KAAK,IAAd,EAAoB;AACpB,MAAIA,KAAK,CAACvC,GAAN,KAAcC,SAAlB,EAA6B;AAE7B,QAAMoD,UAAU,GAAGd,KAAK,CAACvC,GAAN,CAAUsD,OAAV,EAAnB;AACAf,EAAAA,KAAK,CAACvC,GAAN,CAAUuD,UAAV,CAAqB,KAArB;;AAEA,QAAMC,OAAO;AACXzD,IAAAA,OAAO,EAAEwC,KAAK,CAACxC,OADJ;AAEX6C,IAAAA,QAAQ,EAAEO,QAFC;AAGXD,IAAAA,SAAS,EAAEE;AAHA,KAIPb,KAAK,CAAClC,aAAN,IAAuB,EAJhB,CAAb,CATqE,CAgBrE;;;AACA,OAAK,MAAMoD,OAAX,IAAsBhD,UAAtB,EAAkC;AAChC,UAAMF,IAAI,GAAGE,UAAU,CAACgD,OAAD,CAAvB;AACAlD,IAAAA,IAAI,CAACP,GAAL,CAASuD,UAAT,CAAoB,KAApB;;AACA,SAAK,MAAMG,MAAX,IAAqBnD,IAAI,CAACX,MAA1B,EAAkC;AAChC8D,MAAAA,MAAM,CAACC,KAAP,CAAa,CAACpD,IAAI,CAACP,GAAN,CAAb;;AACA,UAAI0D,MAAM,CAACJ,OAAP,EAAJ,EAAsB;AACpB/C,QAAAA,IAAI,CAACP,GAAL,CAASuD,UAAT,CAAoB,IAApB;AACD;AACF;AACF;;AACDhB,EAAAA,KAAK,CAACvC,GAAN,CAAU4D,GAAV,CAAcJ,OAAd;AACAjB,EAAAA,KAAK,CAACvC,GAAN,CAAUuD,UAAV,CAAqBF,UAArB;AACD;;AACD,SAASQ,IAAT,GAAgB;AACdC,EAAAA,IAAI,CAACC,EAAL,CAAQC,SAAR,GAAoB,sBAApB,CADc,CAEd;;AACA,MAAIC,WAAW,GAAG,EAAlB;;AACA,OAAK,MAAMC,EAAX,IAAiBxE,QAAjB,EAA2B;AACzB,QAAIA,QAAQ,CAACwE,EAAD,CAAR,CAAa/D,IAAb,KAAsBF,SAA1B,EAAqC;AACnCP,MAAAA,QAAQ,CAACwE,EAAD,CAAR,CAAa/D,IAAb,GAAoB2D,IAAI,CAACC,EAAL,CAAQI,SAAR,CAAmB,IAAGD,EAAG,EAAzB,CAApB;AACAxE,MAAAA,QAAQ,CAACwE,EAAD,CAAR,CAAa/D,IAAb,CAAkBiE,OAAlB,CAA0B,YAAY;AACpC,YAAI1E,QAAQ,CAACwE,EAAD,CAAR,CAAahE,cAAjB,EAAiCuC,qBAAqB,CAAC/C,QAAQ,CAACwE,EAAD,CAAT,EAAexE,QAAQ,CAACwE,EAAD,CAAR,CAAa/D,IAA5B,CAArB,CAAjC,KACKuB,wBAAwB,CAAChC,QAAQ,CAACwE,EAAD,CAAT,EAAexE,QAAQ,CAACwE,EAAD,CAAR,CAAa/D,IAA5B,CAAxB;AACN,OAHD,EAGG,IAHH;AAID;;AACD,SAAK,MAAMkE,EAAX,IAAiB3E,QAAQ,CAACwE,EAAD,CAAR,CAAatE,MAA9B,EAAsC;AACpC,YAAM0E,SAAS,GAAGD,EAAE,CAACxE,IAArB;AACA,YAAM0C,KAAK,GAAG,IAAIuB,IAAI,CAACS,GAAL,CAASC,KAAb,CAAmBF,SAAnB,CAAd;AACA/B,MAAAA,KAAK,CAACgB,UAAN,CAAiB,KAAjB;AACAc,MAAAA,EAAE,CAACrE,GAAH,GAASuC,KAAT,CAJoC,CAMpC;;AACA,UAAI7C,QAAQ,CAACwE,EAAD,CAAR,CAAa3D,IAAjB,EAAuB;AACrB,cAAM;AAAEA,UAAAA;AAAF,YAAWb,QAAQ,CAACwE,EAAD,CAAzB;;AACA,YAAIzD,UAAU,CAACF,IAAI,CAACV,IAAN,CAAV,KAA0BI,SAA9B,EAAyC;AACvC,gBAAMwE,SAAS,GAAGX,IAAI,CAACC,EAAL,CAAQI,SAAR,CAAmB,IAAG5D,IAAI,CAACV,IAAK,EAAhC,CAAlB;AACA,gBAAM6E,UAAU,GAAG,IAAIZ,IAAI,CAACS,GAAL,CAASC,KAAb,CAAmBjE,IAAI,CAACV,IAAxB,CAAnB;;AACC,WAAC,YAAY;AACZ,kBAAM8E,MAAM,GAAG,MAAMC,KAAK,CAAE,0BAAyBrE,IAAI,CAACV,IAAK,OAArC,CAA1B;AACA,kBAAMgF,UAAU,GAAG,MAAMF,MAAM,CAACG,IAAP,EAAzB;AACAJ,YAAAA,UAAU,CAACK,SAAX,CAAqBN,SAArB,EAAgCI,UAAhC;AACAH,YAAAA,UAAU,CAACd,GAAX,CAAe,EAAf;AACD,WALA;;AAMDc,UAAAA,UAAU,CAACnB,UAAX,CAAsB,KAAtB;AACA9C,UAAAA,UAAU,CAACF,IAAI,CAACV,IAAN,CAAV,GAAwB;AAAED,YAAAA,MAAM,EAAE,EAAV;AAAcI,YAAAA,GAAG,EAAE0E;AAAnB,WAAxB;AACD;;AACDjE,QAAAA,UAAU,CAACF,IAAI,CAACV,IAAN,CAAV,CAAsBD,MAAtB,CAA6BoF,IAA7B,CAAkCzC,KAAlC;AACA8B,QAAAA,EAAE,CAAC9D,IAAH,GAAUE,UAAU,CAACF,IAAI,CAACV,IAAN,CAApB;AACD;;AAEDoE,MAAAA,WAAW,CAACe,IAAZ,CAAiBX,EAAjB;;AACC,OAAC,YAAY;AACZ,cAAMM,MAAM,GAAG,MAAMC,KAAK,CAAE,uBAAsBN,SAAU,OAAlC,CAA1B;AACA,cAAMO,UAAU,GAAG,MAAMF,MAAM,CAACG,IAAP,EAAzB;AACAT,QAAAA,EAAE,CAACrE,GAAH,CAAO+E,SAAP,CAAiBrF,QAAQ,CAACwE,EAAD,CAAR,CAAa/D,IAA9B,EAAoC0E,UAApC;AACD,OAJA;AAKF;AACF;;AACDZ,EAAAA,WAAW,GAAGA,WAAW,CAACgB,IAAZ,CAAiB,UAAUC,CAAV,EAAaC,CAAb,EAAgB;AAC7C,WAAOD,CAAC,CAACpF,GAAF,GAAQqF,CAAC,CAACrF,GAAjB;AACD,GAFa,CAAd;AAGA,QAAMF,MAAM,GAAGqE,WAAW,CAACmB,MAAZ,CAAmBC,MAAM,CAACC,MAAP,CAAc7E,UAAd,CAAnB,CAAf;AACAqD,EAAAA,IAAI,CAACS,GAAL,CAASgB,QAAT,CAAkB;AAChBC,IAAAA,YAAY,EAAE5F,MAAM,CAAC6F,GAAP,CAAW,UAAUC,IAAV,EAAgB;AACvC,aAAOA,IAAI,CAAC1F,GAAZ;AACD,KAFa;AADE,GAAlB;AAKA,SAAOiE,WAAP;AACD;;AACD,SAAS0B,KAAT,CAAe;AACbC,EAAAA,WADa;AAEbC,EAAAA,WAFa;AAGbC,EAAAA,cAHa;AAIbC,EAAAA,mBAJa;AAKbC,EAAAA,iBALa;AAMbrF,EAAAA;AANa,CAAf,EAOQ;AACN,QAAM;AAAA,OAACsF,MAAD;AAAA,OAASC;AAAT,MAAsBzG,QAAQ,CAAQ,EAAR,CAApC;AACAD,EAAAA,SAAS,CAAC,MAAM;AACdsE,IAAAA,IAAI,CAACS,GAAL,CAAS4B,aAAT,CAAuBP,WAAvB;AACAM,IAAAA,SAAS,CAACrC,IAAI,EAAL,CAAT;AACD,GAHQ,EAGN,CAAC+B,WAAD,CAHM,CAAT;AAKApG,EAAAA,SAAS,CAAC,MAAM;AACd,SAAK,MAAM0E,EAAX,IAAiBxE,QAAjB,EAA2B;AACzB,YAAM0G,OAAO,GAAG1F,UAAU,CAAC,IAAImB,IAAJ,EAAD,CAA1B;AACA,UAAInC,QAAQ,CAACwE,EAAD,CAAR,CAAahE,cAAjB,EACEuC,qBAAqB,CAAC/C,QAAQ,CAACwE,EAAD,CAAT,EAAexE,QAAQ,CAACwE,EAAD,CAAR,CAAa/D,IAA5B,EAAkCiG,OAAlC,CAArB;AACH;AACF,GANQ,EAMN,CAACzF,IAAD,CANM,CAAT;AAQAnB,EAAAA,SAAS,CAAC,MAAM;AACdyG,IAAAA,MAAM,CAACI,OAAP,CAAgBC,EAAD,IAAQ;AACrB,UAAI,CAACA,EAAE,CAACzG,IAAH,CAAQ0G,OAAR,CAAgB,YAAhB,CAAL,EAAoC;AAClCD,QAAAA,EAAE,CAACtG,GAAH,CAAOuD,UAAP,CAAkBuC,cAAlB;AACAQ,QAAAA,EAAE,CAAC/F,IAAH,CAAQP,GAAR,CAAYuD,UAAZ,CAAuBuC,cAAvB;AACD;;AACD,UAAIQ,EAAE,CAACzG,IAAH,KAAY,eAAhB,EAAiC;AAC/ByG,QAAAA,EAAE,CAACtG,GAAH,CAAOuD,UAAP,CAAkByC,iBAAlB;AACD;;AACD,UAAIM,EAAE,CAACzG,IAAH,KAAY,iBAAhB,EAAmC;AACjCyG,QAAAA,EAAE,CAACtG,GAAH,CAAOuD,UAAP,CAAkBwC,mBAAlB;AACD;AACF,KAXD;AAYD,GAbQ,EAaN,CAACF,WAAD,EAAcC,cAAd,EAA8BC,mBAA9B,EAAmDC,iBAAnD,EAAsEC,MAAtE,CAbM,CAAT;AAcA,SAAO,IAAP;AACD,C,CACD;;;AAEA,eAAeN,KAAf","sourcesContent":["import { useEffect, useState } from \"react\"\n\nconst elements: Record<string, unknown> = {\n  TropicalStorm: {\n    layers: [{ name: \"TropicalStorm\", idx: 1, element: \"TropicalStorm\", ref: undefined }],\n    timecontrolled: false,\n    data: undefined,\n  },\n  WaveHeight: {\n    layers: [\n      {\n        name: \"WaveHeight\",\n        idx: 10,\n        element: \"HTSGW\",\n        ref: undefined,\n        extraContents: { filter: \"missing 1\" },\n      },\n      {\n        name: \"WaveHeightContour\",\n        idx: 9,\n        element: \"HTSGW\",\n        ref: undefined,\n        extraContents: { filter: \"missing 1\" },\n      },\n    ],\n    timecontrolled: true,\n    data: undefined,\n    mask: { name: \"LandMask\", ref: undefined, data: undefined },\n  },\n  SurfacePressure: {\n    layers: [{ name: \"SurfacePressure\", idx: 5, element: \"PRMSL\", ref: undefined }],\n    timecontrolled: true,\n    data: undefined,\n  },\n}\nconst layerMasks = {}\nfunction reformDate(date: any) {\n  const yy = date.getUTCFullYear()\n  const mm = String(date.getUTCMonth() + 1).padStart(2, \"0\")\n  const dd = String(date.getUTCDate()).padStart(2, \"0\")\n  const HH = String(date.getUTCHours()).padStart(2, \"0\")\n  const MM = String(date.getUTCMinutes()).padStart(2, \"0\")\n  const SS = String(date.getUTCSeconds()).padStart(2, \"0\")\n  return `${yy}${mm}${dd}T${HH}${MM}${SS}`\n}\nfunction updateDataNonTimeContent(source: any, ref: any, time = reformDate(new Date())) {\n  const refindex = ref.query(\"index\").value()\n  const refdata = ref.query(\"data\").value()\n  if (refindex && refindex.index) {\n    for (const id in refindex.index) {\n      const trop = refindex.index[id]\n      if (trop.final_flag === 1 && !trop.valid_end) delete refdata[id]\n      else if (trop.final_flag === 1 && trop.valid_end < time) delete refdata[id]\n    }\n  }\n  for (const layer of source.layers) {\n    updateModelContent(layer, time, time)\n  }\n}\n\nfunction updateDataTimeContent(source: any, ref: any, time = reformDate(new Date())) {\n  let timelist = ref.query(\"timelist\").value()\n  if (timelist && timelist.length) {\n    if (timelist && timelist.length > 1) {\n      if (timelist[0].basetime < timelist[1].basetime) {\n        timelist = timelist.reverse()\n      }\n    }\n\n    // Get Nearest latest BaseTime\n    let bt = \"\"\n    let vl = []\n    let vt = \"\"\n    for (let i = 0; i < timelist.length; i++) {\n      bt = timelist[i].basetime\n      vl = timelist[i].validtime\n      if (bt <= time) break\n    }\n\n    // Get Nearest latest ValidTime\n    for (let i = 0; i < vl.length; i++) {\n      vt = vl[i]\n      if (vt <= time) break\n    }\n\n    for (const layer of source.layers) {\n      updateModelContent(layer, bt, vt)\n    }\n  }\n}\n\nfunction updateModelContent(layer: any, baseTime: any, validTime: any) {\n  if (baseTime === \"\") return\n  if (validTime === \"\") return\n  if (layer === null) return\n  if (layer.ref === undefined) return\n\n  const visibility = layer.ref.visible()\n  layer.ref.setVisible(false)\n\n  const content = {\n    element: layer.element,\n    basetime: baseTime,\n    validtime: validTime,\n    ...(layer.extraContents || {}),\n  }\n\n  // Check Layer Masks\n  for (const mask_id in layerMasks) {\n    const mask = layerMasks[mask_id]\n    mask.ref.setVisible(false)\n    for (const mlayer of mask.layers) {\n      mlayer.merge([mask.ref])\n      if (mlayer.visible()) {\n        mask.ref.setVisible(true)\n      }\n    }\n  }\n  layer.ref.set(content)\n  layer.ref.setVisible(visibility)\n}\nfunction init() {\n  WRAP.DH.conf_path = \"./weatherConfig/data\"\n  // Init Weather Layers\n  let tmp_wx_list = []\n  for (const el in elements) {\n    if (elements[el].data === undefined) {\n      elements[el].data = WRAP.DH.addObject(`/${el}`)\n      elements[el].data.inspect(function () {\n        if (elements[el].timecontrolled) updateDataTimeContent(elements[el], elements[el].data)\n        else updateDataNonTimeContent(elements[el], elements[el].data)\n      }, true)\n    }\n    for (const ly of elements[el].layers) {\n      const layerName = ly.name\n      const layer = new WRAP.Geo.Layer(layerName)\n      layer.setVisible(false)\n      ly.ref = layer\n\n      // Create Layer Mask\n      if (elements[el].mask) {\n        const { mask } = elements[el]\n        if (layerMasks[mask.name] === undefined) {\n          const mask_data = WRAP.DH.addObject(`/${mask.name}`)\n          const mask_layer = new WRAP.Geo.Layer(mask.name)\n          ;(async () => {\n            const result = await fetch(`./resources/conf/layer/${mask.name}.json`)\n            const layer_conf = await result.json()\n            mask_layer.configure(mask_data, layer_conf)\n            mask_layer.set({})\n          })()\n          mask_layer.setVisible(false)\n          layerMasks[mask.name] = { layers: [], ref: mask_layer }\n        }\n        layerMasks[mask.name].layers.push(layer)\n        ly.mask = layerMasks[mask.name]\n      }\n\n      tmp_wx_list.push(ly)\n      ;(async () => {\n        const result = await fetch(`./weatherConf/layer/${layerName}.json`)\n        const layer_conf = await result.json()\n        ly.ref.configure(elements[el].data, layer_conf)\n      })()\n    }\n  }\n  tmp_wx_list = tmp_wx_list.sort(function (a, b) {\n    return a.idx - b.idx\n  })\n  const layers = tmp_wx_list.concat(Object.values(layerMasks))\n  WRAP.Geo.setLayer({\n    upper_layers: layers.map(function (item) {\n      return item.ref\n    }),\n  })\n  return tmp_wx_list\n}\nfunction Index({\n  guardianMap,\n  onSetLayers,\n  showWaveHeight,\n  showPressurePattern,\n  showTropicalStorm,\n  date,\n}: any) {\n  const [wxList, setWxList] = useState<any[]>([])\n  useEffect(() => {\n    WRAP.Geo.setOpenLayers(guardianMap)\n    setWxList(init())\n  }, [guardianMap])\n\n  useEffect(() => {\n    for (const el in elements) {\n      const newdate = reformDate(new Date())\n      if (elements[el].timecontrolled)\n        updateDataTimeContent(elements[el], elements[el].data, newdate)\n    }\n  }, [date])\n\n  useEffect(() => {\n    wxList.forEach((wx) => {\n      if (!wx.name.indexOf(\"WaveHeight\")) {\n        wx.ref.setVisible(showWaveHeight)\n        wx.mask.ref.setVisible(showWaveHeight)\n      }\n      if (wx.name === \"TropicalStorm\") {\n        wx.ref.setVisible(showTropicalStorm)\n      }\n      if (wx.name === \"SurfacePressure\") {\n        wx.ref.setVisible(showPressurePattern)\n      }\n    })\n  }, [onSetLayers, showWaveHeight, showPressurePattern, showTropicalStorm, wxList])\n  return null\n}\n// const mapStateToProps = (state: any, props: any) => state.cargoMap.weatherForecast\n\nexport default Index\n"]},"metadata":{},"sourceType":"module"}