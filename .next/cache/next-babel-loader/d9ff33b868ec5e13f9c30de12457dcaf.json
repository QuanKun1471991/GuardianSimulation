{"ast":null,"code":"import _conformsTo from \"lodash/conformsTo\";\nimport _isFunction from \"lodash/isFunction\";\nimport _isEmpty from \"lodash/isEmpty\";\nimport _isString from \"lodash/isString\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { SagaInjectionModes } from \"core/constants/common\";\nimport checkStore, { invariant } from \"core/utils/redux\";\n\nconst checkKey = key => invariant(_isString(key) && !_isEmpty(key), \"(app/utils...) injectSaga: Expected `key` to be a non empty string\");\n\nconst checkDescriptor = descriptor => {\n  const shape = {\n    saga: _isFunction,\n    mode: mode => _isString(mode)\n  };\n  invariant(_conformsTo(descriptor, shape), \"(app/utils...) injectSaga: Expected a valid saga descriptor\");\n};\n\nexport function injectSagaFactory(store, isValid) {\n  return function injectSaga(key, descriptor, args) {\n    if (!isValid) {\n      checkStore(store);\n    }\n\n    const newDescriptor = _objectSpread(_objectSpread({}, descriptor), {}, {\n      mode: descriptor.mode || SagaInjectionModes.DAEMON\n    });\n\n    const {\n      saga,\n      mode\n    } = newDescriptor;\n    checkKey(key);\n    checkDescriptor(newDescriptor);\n    let hasSaga = Reflect.has(store.injectedSagas, key);\n\n    if (false) {\n      const oldDescriptor = store.injectedSagas[key]; // enable hot reloading of daemon and once-till-unmount sagas\n\n      if (hasSaga && oldDescriptor.saga !== saga) {\n        oldDescriptor.task.cancel();\n        hasSaga = false;\n      }\n    }\n\n    if (!hasSaga || hasSaga && mode !== SagaInjectionModes.DAEMON && mode !== SagaInjectionModes.ONCE_TILL_UNMOUNT) {\n      var _store$runSaga;\n\n      // eslint-disable-next-line no-param-reassign\n      store.injectedSagas = _objectSpread(_objectSpread({}, store.injectedSagas), {}, {\n        [key]: _objectSpread(_objectSpread({}, newDescriptor), {}, {\n          task: (_store$runSaga = store.runSaga) === null || _store$runSaga === void 0 ? void 0 : _store$runSaga.call(store, saga, args)\n        })\n      });\n    }\n\n    return store;\n  };\n}\nexport function ejectSagaFactory(store, isValid) {\n  return function ejectSaga(key) {\n    if (!isValid) {\n      checkStore(store);\n    }\n\n    checkKey(key);\n\n    if (Reflect.has(store.injectedSagas, key)) {\n      const descriptor = store.injectedSagas[key];\n\n      if (descriptor.mode && descriptor.mode !== SagaInjectionModes.DAEMON) {\n        descriptor.task.cancel(); // Clean up in production; in development we need `descriptor.saga` for hot reloading\n\n        if (true) {\n          // Need some value to be able to detect `ONCE_TILL_UNMOUNT` sagas in `injectSaga`\n          store.injectedSagas[key] = \"done\"; // eslint-disable-line no-param-reassign\n        }\n      }\n    }\n\n    return store;\n  };\n}\nexport default function getInjectors(store) {\n  checkStore(store);\n  return {\n    injectSaga: injectSagaFactory(store, true),\n    ejectSaga: ejectSagaFactory(store, true)\n  };\n}","map":null,"metadata":{},"sourceType":"module"}