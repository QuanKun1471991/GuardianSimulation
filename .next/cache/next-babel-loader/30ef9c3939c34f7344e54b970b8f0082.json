{"ast":null,"code":"import _conformsTo from \"lodash/conformsTo\";\nimport _isObject from \"lodash/isObject\";\nimport _isFunction from \"lodash/isFunction\";\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nexport function invariant(cond, error) {\n  if (!cond && true) {\n    throw new Error(error);\n  }\n}\nexport default function checkStore(_ref) {\n  let {\n    dispatch,\n    subscribe\n  } = _ref,\n      store = _objectWithoutProperties(_ref, [\"dispatch\", \"subscribe\"]);\n\n  const shape = {\n    getState: _isFunction,\n    replaceReducer: _isFunction,\n    runSaga: _isFunction,\n    injectedReducers: _isObject,\n    injectedSagas: _isObject\n  };\n  invariant(_conformsTo(dispatch, _isFunction) && _conformsTo(subscribe, _isFunction) && _conformsTo(store, shape), \"Injectors: Expected a valid redux store\");\n}","map":{"version":3,"sources":["/Users/tonysan/Desktop/guardian-simulation/GuardianSimulation/src/core/utils/redux.ts"],"names":["invariant","cond","error","Error","checkStore","dispatch","subscribe","store","shape","getState","replaceReducer","runSaga","injectedReducers","injectedSagas"],"mappings":";;;;;;;;AAGA,OAAO,SAASA,SAAT,CAAmBC,IAAnB,EAAkCC,KAAlC,EAAiD;AACtD,MAAI,CAACD,IAAD,QAAJ,EAAoD;AAClD,UAAM,IAAIE,KAAJ,CAAUD,KAAV,CAAN;AACD;AACF;AAED,eAAe,SAASE,UAAT,OAAsE;AAAA,MAAlD;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,GAAkD;AAAA,MAAxBC,KAAwB;;AACnF,QAAMC,KAAK,GAAG;AACZC,IAAAA,QAAQ,aADI;AAEZC,IAAAA,cAAc,aAFF;AAGZC,IAAAA,OAAO,aAHK;AAIZC,IAAAA,gBAAgB,WAJJ;AAKZC,IAAAA,aAAa;AALD,GAAd;AAQAb,EAAAA,SAAS,CACP,YAAWK,QAAX,kBACE,YAAWC,SAAX,cADF,IAEE,YAAWC,KAAX,EAAkBC,KAAlB,CAHK,EAIP,yCAJO,CAAT;AAMD","sourcesContent":["import { conformsTo, isFunction, isObject } from \"lodash\"\nimport { InjectedStore } from \"types/redux\"\n\nexport function invariant(cond: boolean, error: string) {\n  if (!cond && process.env.NODE_ENV !== \"production\") {\n    throw new Error(error)\n  }\n}\n\nexport default function checkStore({ dispatch, subscribe, ...store }: InjectedStore) {\n  const shape = {\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    injectedReducers: isObject,\n    injectedSagas: isObject,\n  }\n\n  invariant(\n    conformsTo(dispatch, isFunction) &&\n      conformsTo(subscribe, isFunction) &&\n      conformsTo(store, shape),\n    \"Injectors: Expected a valid redux store\"\n  )\n}\n"]},"metadata":{},"sourceType":"module"}