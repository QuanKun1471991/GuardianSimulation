{"ast":null,"code":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nimport { conformsTo, isFunction, isObject } from \"lodash\";\nexport function invariant(cond, error) {\n  if (!cond && true) {\n    throw new Error(error);\n  }\n}\nexport default function checkStore(_ref) {\n  let {\n    dispatch,\n    subscribe\n  } = _ref,\n      store = _objectWithoutProperties(_ref, [\"dispatch\", \"subscribe\"]);\n\n  const shape = {\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    injectedReducers: isObject,\n    injectedSagas: isObject\n  };\n  invariant(conformsTo(dispatch, isFunction) && conformsTo(subscribe, isFunction) && conformsTo(store, shape), \"Injectors: Expected a valid redux store\");\n}","map":{"version":3,"sources":["/Users/tonysan/Desktop/guardian-simulation/GuardianSimulation/src/core/utils/redux.ts"],"names":["conformsTo","isFunction","isObject","invariant","cond","error","Error","checkStore","dispatch","subscribe","store","shape","getState","replaceReducer","runSaga","injectedReducers","injectedSagas"],"mappings":";;;;AAAA,SAASA,UAAT,EAAqBC,UAArB,EAAiCC,QAAjC,QAAiD,QAAjD;AAGA,OAAO,SAASC,SAAT,CAAmBC,IAAnB,EAAkCC,KAAlC,EAAiD;AACtD,MAAI,CAACD,IAAD,QAAJ,EAAoD;AAClD,UAAM,IAAIE,KAAJ,CAAUD,KAAV,CAAN;AACD;AACF;AAED,eAAe,SAASE,UAAT,OAAsE;AAAA,MAAlD;AAAEC,IAAAA,QAAF;AAAYC,IAAAA;AAAZ,GAAkD;AAAA,MAAxBC,KAAwB;;AACnF,QAAMC,KAAK,GAAG;AACZC,IAAAA,QAAQ,EAAEX,UADE;AAEZY,IAAAA,cAAc,EAAEZ,UAFJ;AAGZa,IAAAA,OAAO,EAAEb,UAHG;AAIZc,IAAAA,gBAAgB,EAAEb,QAJN;AAKZc,IAAAA,aAAa,EAAEd;AALH,GAAd;AAQAC,EAAAA,SAAS,CACPH,UAAU,CAACQ,QAAD,EAAWP,UAAX,CAAV,IACED,UAAU,CAACS,SAAD,EAAYR,UAAZ,CADZ,IAEED,UAAU,CAACU,KAAD,EAAQC,KAAR,CAHL,EAIP,yCAJO,CAAT;AAMD","sourcesContent":["import { conformsTo, isFunction, isObject } from \"lodash\"\nimport { InjectedStore } from \"types/redux\"\n\nexport function invariant(cond: boolean, error: string) {\n  if (!cond && process.env.NODE_ENV !== \"production\") {\n    throw new Error(error)\n  }\n}\n\nexport default function checkStore({ dispatch, subscribe, ...store }: InjectedStore) {\n  const shape = {\n    getState: isFunction,\n    replaceReducer: isFunction,\n    runSaga: isFunction,\n    injectedReducers: isObject,\n    injectedSagas: isObject,\n  }\n\n  invariant(\n    conformsTo(dispatch, isFunction) &&\n      conformsTo(subscribe, isFunction) &&\n      conformsTo(store, shape),\n    \"Injectors: Expected a valid redux store\"\n  )\n}\n"]},"metadata":{},"sourceType":"module"}